From dc239c1e20f2e5b85c4b11023876f1eac3c6ad70 Mon Sep 17 00:00:00 2001
From: Ricardo Cerqueira <ricardo@cyngn.com>
Date: Tue, 4 Nov 2014 15:14:08 +0000
Subject: [PATCH] jni: Skip loading FM firmware if requested

Not all boards require a firmware download for FM. Set
TARGET_QCOM_NO_FM_FIRMWARE if the device doesn't require
a fw image to run FM

Change-Id: If18650af934f840a54f53fa9474a3341df0e3e68

jni: Confine the firmware-load skipping to the actual loading

Change If18650af934f840a54f53fa9474a3341df0e3e68 removed the
property-setting steps from the initialization routine. Bring it
back, as we may want to use those properties to trigger module
state changes from init. The recommended flow for devices with
the latest IRIS driver is the following:

on property:vendor.hw.fm.init=0
    write /sys/module/radio_iris_transport/parameters/fmsmd_set 0

on property:vendor.hw.fm.init=1
    write /sys/module/radio_iris_transport/parameters/fmsmd_set 1

Change-Id: Ifddf678398fec2e4bfa9688c044da7d75898e056

jni: Resolve property isolation issues

* Set system instead of vendor properties for FM init
  on devices that don't use firmware download.

Change-Id: I8f77a4f822ec8c609fe3526d7e96ea19d46cb1f8
---
 jni/Android.bp              |  3 +++
 jni/android_hardware_fm.cpp | 17 +++++++++++++++--
 2 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/jni/Android.bp b/jni/Android.bp
index accdc37..374508f 100755
--- a/jni/Android.bp
+++ b/jni/Android.bp
@@ -1,5 +1,8 @@
 cc_library_shared {
     name: "libqcomfm_jni",
+    defaults: [
+        "qcom_no_fm_firmware_defaults",
+    ],
 
     system_ext_specific: true,
     srcs: [
diff --git a/jni/android_hardware_fm.cpp b/jni/android_hardware_fm.cpp
index c7d4463..22269c8 100644
--- a/jni/android_hardware_fm.cpp
+++ b/jni/android_hardware_fm.cpp
@@ -573,12 +573,14 @@ static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
         (JNIEnv* env, jobject thiz __unused, jstring path)
 {
     int fd;
-    int i = 0, err;
     char value[PROPERTY_VALUE_MAX] = {'\0'};
+    jboolean isCopy;
+#ifndef QCOM_NO_FM_FIRMWARE
+    int i = 0, err;
     char versionStr[40] = {'\0'};
     int init_success = 0;
-    jboolean isCopy;
     v4l2_capability cap;
+#endif
     const char* radio_path = env->GetStringUTFChars(path, &isCopy);
     if(radio_path == NULL){
         return FM_JNI_FAILURE;
@@ -590,6 +592,7 @@ static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
     if(fd < 0){
         return FM_JNI_FAILURE;
     }
+#ifndef QCOM_NO_FM_FIRMWARE
     //Read the driver verions
     err = ioctl(fd, VIDIOC_QUERYCAP, &cap);
 
@@ -604,6 +607,7 @@ static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
        close(fd);
        return FM_JNI_FAILURE;
     }
+#endif
 
     property_get("vendor.qcom.bluetooth.soc", value, NULL);
 
@@ -611,6 +615,7 @@ static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
 
     if ((strcmp(value, "rome") != 0) && (strcmp(value, "hastings") != 0))
     {
+#ifndef QCOM_NO_FM_FIRMWARE
        /*Set the mode for soc downloader*/
        property_set("vendor.hw.fm.mode", "normal");
        /* Need to clear the hw.fm.init firstly */
@@ -633,6 +638,10 @@ static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
          close(fd);
          return FM_JNI_FAILURE;
        }
+#else
+       property_set("hw.fm.init", "1");
+       usleep(WAIT_TIMEOUT);
+#endif
     }
     return fd;
 }
@@ -649,7 +658,11 @@ static jint android_hardware_fmradio_FmReceiverJNI_closeFdNative
 
     if ((strcmp(value, "rome") != 0) && (strcmp(value, "hastings") != 0))
     {
+#ifndef QCOM_NO_FM_FIRMWARE
         property_set("ctl.stop", "vendor.fm");
+#else
+        property_set("hw.fm.init", "0");
+#endif
     }
     close(fd);
     return FM_JNI_SUCCESS;
-- 
2.36.1

